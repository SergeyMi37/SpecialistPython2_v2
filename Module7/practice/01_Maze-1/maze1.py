# Выверите и скопируйте сюда наиболее подходяший алгоритм для работы с графом(bfs/dfs)
def dfs(graph, start):
    visited = [False] * len(graph)

    def _dfs(v):
        visited[v] = True
        for w in graph[v]:
            if not visited[w]:  # посещён ли текущий сосед?
                _dfs(w)

    _dfs(start)
    return visited

# Опишите список смежности по изображению лабиринта из файла task.md
graph = [
    [1], #0
    [0,5], #1
    [6], #2
    [7], #3
    [5,8], #4
    [1,4], #5
    [2,10], #6
    [3], #7
    [4,9,12], #8
    [8,10], #9
    [6,9,11,14], #10
    [10], #11
    [8], #12
    [], #13
    [10], #14
    [14] #15
           
]

# Решите задачу и выведите ответ в нужном формате
# S-1,S-2,S-3 - точки старта

# Определите: Из каких точек можно дойти до финиша(F), а из каких нет.

# **Выведите ответ в формате:**: \
# Из точки S-1 можно дойти до финиша \
# ... \
# Из точки S-3 нельзя дойти до финиша
finish_=14
start_points=[
    {"name":"S-1","num":0},
    {"name":"S-2","num":12},
    {"name":"S-3","num":3},
]
for point in start_points:
    vis=dfs(graph=graph,start=point["num"])
    yes="можно" 
    if not vis[finish_]: yes="нельзя"
    print(f'Из точки {point["name"]} {yes} дойти до финиша')
